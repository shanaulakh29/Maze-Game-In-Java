1. Progressive Reveal of the Maze
        One of the key features of our game is how the maze gradually reveals itself to the player as the mouse moves. This decision creates a nice exploratory element to the game. To support this feature, we designed the GameController class to manage the game state/logic, including which parts of the maze were visible to the player. The Mouse class collaborates with the GameController class as it tracks the current location of the mouse, which helps the GameController to identify and store the adjacent cells that should be revealed with each move. The already-revealed cells stay visible for the rest of the game session.
The main method for this feature will be the lookForCurrentNeighboursAndAllVisitedAndDisclosedNeighbours(). This method is crucial to this feature as it will calculate which cells are currently adjacent to the mouse, ensuring that only those cells as well as previously disclosed paths and neighbours are considered. Specifically, the method will consider all eight possible neighbours of the mouse (up, down, left, right, and diagonals). For every neighbouring cell, it will check whether the cell is within the maze boundaries and if it is a valid path. If the cell meets these criteria and has not been previously visited, it is added to the list of visible cells. 
This approach will maintain a clear separation of responsibilities. The Mouse class knows its position in the maze while the GameController class manages the game logic. The Menu class in the View package presents the visual representation to the player.


2. Handling User Input
        Another core part of our game will be handling the user input. In our OOD, the Menu class will be responsible for interacting with the player – collecting their command inputs or other actions such as cheat codes or help requests. This input will then be checked for validation in the Menu class before being passed on to the GameController class for processing.
        The GameController class will take the validated input and update the game state accordingly – moving the mouse. By designing it this way, the Menu class is only concerned with handling the input/output operations and uses the game logic defined inside the GameController in the Model package to make this a fun game.
